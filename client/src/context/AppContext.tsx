import React, { createContext, useContext, useReducer, ReactNode, useEffect } from 'react';
import { api } from '../services/http';

export interface User {
  id: string; // Backend returns 'id' not '_id'
  userId: string; // Generated user ID for admin/seller, email for customer
  email: string;
  name: string;
  role: 'superadmin' | 'admin' | 'seller' | 'customer';
  isActive: boolean;
  mustChangePassword: boolean; // For admin/seller to change password on first login
  createdAt: string;
  lastLoginAt?: string;
}

interface CartItem {
  _id: string;
  title: string;
  price: number;
  category: string;
  quantity: number;
}

interface AppState {
  user: User | null;
  cart: CartItem[];
  isLoading: boolean;
  isInitializing: boolean;
  searchQuery: string;
  selectedCategory: string;
  isAuthenticated: boolean;
}

type AppAction =
  | { type: 'SET_USER'; payload: User | null }
  | { type: 'SET_LOADING'; payload: boolean }
  | { type: 'SET_INITIALIZING'; payload: boolean }
  | { type: 'ADD_TO_CART'; payload: any }
  | { type: 'REMOVE_FROM_CART'; payload: string }
  | { type: 'CLEAR_CART' }
  | { type: 'SET_SEARCH'; payload: string }
  | { type: 'SET_CATEGORY'; payload: string }
  | { type: 'LOGOUT' }
  | { type: 'UPDATE_USER'; payload: Partial<User> };

const initialState: AppState = {
  user: null,
  cart: [],
  isLoading: false,
  isInitializing: true,
  searchQuery: '',
  selectedCategory: 'all',
  isAuthenticated: false,
};

const appReducer = (state: AppState, action: AppAction): AppState => {
  switch (action.type) {
    case 'SET_USER':
      return { ...state, user: action.payload, isAuthenticated: !!action.payload };
    case 'SET_LOADING':
      return { ...state, isLoading: action.payload };
    case 'SET_INITIALIZING':
      return { ...state, isInitializing: action.payload };
    case 'ADD_TO_CART':
      const existingItem = state.cart.find(item => item._id === action.payload._id);
      if (existingItem) {
        return {
          ...state,
          cart: state.cart.map(item =>
            item._id === action.payload._id
              ? { ...item, quantity: item.quantity + 1 }
              : item
          ),
        };
      }
      return { ...state, cart: [...state.cart, { ...action.payload, quantity: 1 }] };
    case 'REMOVE_FROM_CART':
      return { ...state, cart: state.cart.filter(item => item._id !== action.payload) };
    case 'CLEAR_CART':
      return { ...state, cart: [] };
    case 'SET_SEARCH':
      return { ...state, searchQuery: action.payload };
    case 'SET_CATEGORY':
      return { ...state, selectedCategory: action.payload };
    case 'LOGOUT':
      return { ...state, user: null, isAuthenticated: false, cart: [] };
    case 'UPDATE_USER':
      return { ...state, user: state.user ? { ...state.user, ...action.payload } : null };
    default:
      return state;
  }
};

interface AppContextType {
  state: AppState;
  dispatch: React.Dispatch<AppAction>;
  login: (userId: string, password: string) => Promise<void>;
  logout: () => void;
  addToCart: (product: any) => void;
  changePassword: (currentPassword: string, newPassword: string) => Promise<void>;
  createUser: (userData: CreateUserData) => Promise<void>;
  registerCustomer: (customerData: CustomerRegistrationData) => Promise<void>;
  updateUser: (userId: string, userData: Partial<User>) => Promise<void>;
  deleteUser: (userId: string) => Promise<void>;
  activateUser: (userId: string) => Promise<void>;
  deactivateUser: (userId: string) => Promise<void>;
  hardDeleteUser: (userId: string) => Promise<void>;
  getUsers: (role?: string) => Promise<User[]>;
  checkAuthStatus: () => Promise<void>;
}

interface CreateUserData {
  userId: string;
  email: string;
  name: string;
  role: 'admin' | 'seller';
  password?: string; // Optional for admin/seller (generated by superadmin)
}

interface CustomerRegistrationData {
  name: string;
  email: string;
  password: string;
  phone?: string;
  address?: string;
}

const AppContext = createContext<AppContextType | undefined>(undefined);

export const AppProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [state, dispatch] = useReducer(appReducer, initialState);

  // Check authentication status on app load
  useEffect(() => {
    // Add a small delay to prevent rapid successive calls
    const timer = setTimeout(() => {
      checkAuthStatus();
    }, 100);
    
    return () => clearTimeout(timer);
  }, []);

  const checkAuthStatus = async () => {
    const token = localStorage.getItem('token');
    if (token) {
      try {
        const res = await api.get('/auth/me');
        dispatch({ type: 'SET_USER', payload: res.data.user });
      } catch (error: any) {
        // Handle 429 (Too Many Requests) gracefully
        if (error.response?.status === 429) {
          console.warn('Rate limited, will retry later');
          // Mark as initialized even on rate limit to prevent infinite loops
          dispatch({ type: 'SET_INITIALIZING', payload: false });
          return;
        }
        localStorage.removeItem('token');
        dispatch({ type: 'SET_USER', payload: null });
      }
    }
    // Mark initialization as complete
    dispatch({ type: 'SET_INITIALIZING', payload: false });
  };

  const login = async (userId: string, password: string) => {
    dispatch({ type: 'SET_LOADING', payload: true });
    try {
      // Determine if userId is email or actual userId
      const isEmail = userId.includes('@');
      const loginData = isEmail ? { email: userId, password } : { userId, password };
      
      const res = await api.post('/auth/login', loginData);
      const { token, user } = res.data;
      
      localStorage.setItem('token', token);
      dispatch({ type: 'SET_USER', payload: user });
    } catch (error: any) {
      throw new Error(error.response?.data?.message || 'Invalid credentials');
    } finally {
      dispatch({ type: 'SET_LOADING', payload: false });
    }
  };

  const logout = () => {
    localStorage.removeItem('token');
    dispatch({ type: 'LOGOUT' });
    // Reset initialization state when logging out
    dispatch({ type: 'SET_INITIALIZING', payload: false });
  };

  const addToCart = (product: any) => {
    dispatch({ type: 'ADD_TO_CART', payload: product });
  };

  const changePassword = async (currentPassword: string, newPassword: string) => {
    try {
      const res = await api.put('/auth/updatepassword', { currentPassword, newPassword });
      dispatch({ type: 'UPDATE_USER', payload: { mustChangePassword: false } });
      return res.data;
    } catch (error: any) {
      throw new Error(error.response?.data?.message || 'Failed to change password');
    }
  };

  const createUser = async (userData: CreateUserData) => {
    try {
      const res = await api.post('/users', userData);
      return res.data;
    } catch (error: any) {
      throw new Error(error.response?.data?.message || 'Failed to create user');
    }
  };

  const registerCustomer = async (customerData: CustomerRegistrationData) => {
    try {
      const res = await api.post('/auth/register', customerData);
      return res.data;
    } catch (error: any) {
      throw new Error(error.response?.data?.message || 'Failed to register customer');
    }
  };

  const updateUser = async (userId: string, userData: Partial<User>) => {
    try {
      const res = await api.put(`/users/${userId}`, userData);
      return res.data;
    } catch (error: any) {
      throw new Error(error.response?.data?.message || 'Failed to update user');
    }
  };

  const deleteUser = async (userId: string) => {
    try {
      const res = await api.delete(`/users/${userId}`);
      return res.data;
    } catch (error: any) {
      throw new Error(error.response?.data?.message || 'Failed to delete user');
    }
  };

  const activateUser = async (userId: string) => {
    try {
      console.log('ðŸ” Activating user:', userId);
      const res = await api.put(`/users/${userId}/activate`);
      console.log('ðŸ” Activate response:', res);
      return res.data;
    } catch (error: any) {
      console.error('ðŸ” Activate error:', error);
      console.error('ðŸ” Error response:', error.response);
      throw new Error(error.response?.data?.message || 'Failed to activate user');
    }
  };

  const deactivateUser = async (userId: string) => {
    try {
      console.log('ðŸ” Deactivating user:', userId);
      const res = await api.put(`/users/${userId}/deactivate`);
      console.log('ðŸ” Deactivate response:', res);
      return res.data;
    } catch (error: any) {
      console.error('ðŸ” Deactivate error:', error);
      console.error('ðŸ” Error response:', error.response);
      throw new Error(error.response?.data?.message || 'Failed to deactivate user');
    }
  };

  const hardDeleteUser = async (userId: string) => {
    try {
      const res = await api.delete(`/users/${userId}/hard-delete`);
      return res.data;
    } catch (error: any) {
      throw new Error(error.response?.data?.message || 'Failed to permanently delete user');
    }
  };

  const getUsers = async (role?: string) => {
    try {
      const params = role ? { role } : {};
      const res = await api.get('/users', { params });
      return res.data.data || res.data; // Handle both response formats
    } catch (error: any) {
      throw new Error(error.response?.data?.message || 'Failed to fetch users');
    }
  };

  return (
    <AppContext.Provider value={{
      state,
      dispatch,
      login,
      logout,
      addToCart,
      changePassword,
      createUser,
      registerCustomer,
      updateUser,
      deleteUser,
      activateUser,
      deactivateUser,
      hardDeleteUser,
      getUsers,
      checkAuthStatus,
    }}>
      {children}
    </AppContext.Provider>
  );
};

export const useAppContext = () => {
  const context = useContext(AppContext);
  if (context === undefined) {
    throw new Error('useAppContext must be used within an AppProvider');
  }
  return context;
};
